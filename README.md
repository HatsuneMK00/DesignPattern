# DesignPattern

## 学习计划

每天4个设计模式的样例代码实现，后面的设计模式由于没有看过可能速度会降低

## **六大原则**

### 依赖倒置原则

### 开闭原则

### 迪米特法则

### 单一职责原则

让一个类发生修改的原因只能有一个

### 里氏替换法则

### 接口隔离原则

不同的功能需要分不同的接口，接口中不能有无用的方法。当出现无用的方法时，应当对接口进行拆分，是这个原则的指导思想。

## 2019/10/7更新 按照书上章节顺序

### 单例模式

### 工厂方法模式

用于生产复杂对象（产品对象）

#### 简单工厂模式

去掉了工厂方法模式中的抽象工厂类

#### 多工厂模式

该模式中，所有的具体产品类都要有一个具体工厂类负责生产，但是意义有些不明，并且这个和抽象工厂模式有些类似（但是从书上看内容还挺不一样的）

#### 懒加载工厂模式

该模式中，工厂会使用一个Map缓存生产的产品，当要求生产某一个具体产品类时，如果已经生产过，则直接从Map中返回

### 抽象工厂模式

该模式用于复杂场景：产品类有n个产品族，m个产品等级（产品类型），在抽象工厂类中，要有n个生产函数，并且有m个实现工厂类负责生产同一个产品类型（产品等级）的所有产品族的产品

### 模板方法模式

### 遗留问题

对于工厂方法模式和抽象工厂模式，两个模式的通用类图是几乎完全一致的，不知道这两种模式之间有何区别。

## 2019/10/8更新

### 建造者模式

建造者模式设计模式之禅与图解设计模式两本书上有较大的差异，前者在建造者模式中结合了模板方法模式，但它加入具体产品类的原因我不太清楚，将具体产品类这一抽象去除后，得到了与图解设计模式中类似的建造者模式类图与代码。

建造者模式适用于关注对象方法执行顺序的场景，即不同的执行顺序（或对象的装配顺序）会带来不同的效果，与模板方法模式配合使用效果很好。

### 代理模式

代理模式在各式框架中的使用都很多，最为重要的是其中的动态代理，用于实现AOP编程。原始的动态代理只能代理实现了接口的类，即接口的实现类，而使用CGLIB字节码增强等方法可以去除此限制。

代理模式为什么是采用实现同一个接口，而不是继承需要代理的类呢（实现同一个接口也能做到对外界封装的代理，因为面向接口编程，使用的是接口，并不知道使用了代理（如果用了工厂方法模式的话））



> 设计模式之禅
