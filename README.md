# DesignPattern

## 学习计划

每天4个设计模式的样例代码实现，后面的设计模式由于没有看过可能速度会降低

## **六大原则**

### 依赖倒置原则

### 开闭原则

### 迪米特法则

### 单一职责原则

让一个类发生修改的原因只能有一个

### 里氏替换法则

### 接口隔离原则

不同的功能需要分不同的接口，接口中不能有无用的方法。当出现无用的方法时，应当对接口进行拆分，是这个原则的指导思想。

## 2019/10/7更新 按照书上章节顺序

### 单例模式

### 工厂方法模式

用于生产复杂对象（产品对象）

#### 简单工厂模式

去掉了工厂方法模式中的抽象工厂类

#### 多工厂模式

该模式中，所有的具体产品类都要有一个具体工厂类负责生产，但是意义有些不明，并且这个和抽象工厂模式有些类似（但是从书上看内容还挺不一样的）

#### 懒加载工厂模式

该模式中，工厂会使用一个Map缓存生产的产品，当要求生产某一个具体产品类时，如果已经生产过，则直接从Map中返回

### 抽象工厂模式

该模式用于复杂场景：产品类有n个产品族，m个产品等级（产品类型），在抽象工厂类中，要有n个生产函数，并且有m个实现工厂类负责生产同一个产品类型（产品等级）的所有产品族的产品

### 模板方法模式

### 遗留问题

对于工厂方法模式和抽象工厂模式，两个模式的通用类图是几乎完全一致的，不知道这两种模式之间有何区别。

## 2019/10/8更新

### 建造者模式

建造者模式设计模式之禅与图解设计模式两本书上有较大的差异，前者在建造者模式中结合了模板方法模式，但它加入具体产品类的原因我不太清楚，将具体产品类这一抽象去除后，得到了与图解设计模式中类似的建造者模式类图与代码。

建造者模式适用于关注对象方法执行顺序的场景，即不同的执行顺序（或对象的装配顺序）会带来不同的效果，与模板方法模式配合使用效果很好。

### 代理模式

代理模式在各式框架中的使用都很多，最为重要的是其中的动态代理，用于实现AOP编程。原始的动态代理只能代理实现了接口的类，即接口的实现类，而使用CGLIB字节码增强等方法可以去除此限制。

代理模式为什么是采用实现同一个接口，而不是继承需要代理的类呢（实现同一个接口也能做到对外界封装的代理，因为面向接口编程，使用的是接口，并不知道使用了代理（如果用了工厂方法模式的话））

#### 动态代理模式

动态代理模式是代理模式中的重头戏，在使用过程中，动态代理与被代理的业务类完全隔离。

**动态代理的实现过程为：**

1. 编写一个InvocationHandler的实现类，其中包含一个Aspect类，该切面类实现IAdvice接口（即增强方法）。

2. 通过Proxy.newProxyInstance方法生成一个业务类的代理类，并使用接口接收该类。

3. 实际使用过程中，可以为业务类实现一个工厂方法模式，在工厂方法中返回一个增强过的代理类，或是使用一个DynamicProxy工厂类封装返回动态代理类的过程（使用泛型方法避免强转），更可以实现一个DynamicProxy工厂类的具体实现类专门生产对应业务类的代理。

4. 但是个人认为使用工厂方法直接返回一个业务类的代理更加好。

AOP编程可以以一种（继承之外的）很好的方式实现代码重用与添加功能。

### 遗留问题

普通的代理模式只是对被代理类（真是对象）的一层封装，感觉意义不大而且和适配器模式有点像？

为什么不通过创建一个被代理类的子类的方式实现代理，AOP编程和增强呢。

> 设计模式之禅
